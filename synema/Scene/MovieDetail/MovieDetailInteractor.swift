//
//  MovieDetailInteractor.swift
//  synema
//
//  Created by syndromme on 24/06/19.
//  Copyright (c) 2019 syndromme. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import RxSwift
import Moya

protocol MovieDetailBusinessLogic
{
  func fetchMovieDetail()
  func fetchTrailer()
  func fetchReview(page: Int)
}

protocol MovieDetailDataStore
{
  var movie: Movie { get set }
}

class MovieDetailInteractor: MovieDetailBusinessLogic, MovieDetailDataStore
{
  var presenter: MovieDetailPresentationLogic?
  var worker: MovieDetailWorker?
  var movie: Movie = Movie()
  
  // MARK:
  func fetchMovieDetail() {
    worker = MovieDetailWorker()
    worker?.requestMovies(path: "\(movie.movieID)")
      .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .background))
      .observeOn(MainScheduler.instance)
      .subscribe(onSuccess: { (result) in
        self.presenter?.presentMovie(response: result)
      }, onError: { (error) in
        let errorDict = [Constant.errorKey : error.localizedDescription]
        NotificationCenter.default.post(name: NSNotification.Name(rawValue: "error"), object: nil, userInfo: errorDict as [AnyHashable : Any])
      })
  }
  
  func fetchReview(page: Int) {
    worker = MovieDetailWorker()
    let req = MovieDetail.APIModel.Request(JSON: ["page": page])
    worker?.requestReview(path: "\(movie.movieID)", request: req!)
      .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .background))
      .observeOn(MainScheduler.instance)
      .subscribe(onSuccess: { (result) in
        self.presenter?.presentReview(response: result.reviews)
      }, onError: { (error) in
        let errorDict = [Constant.errorKey : error.localizedDescription]
        NotificationCenter.default.post(name: NSNotification.Name(rawValue: "error"), object: nil, userInfo: errorDict as [AnyHashable : Any])
      })
  }
  
  func fetchTrailer() {
    worker = MovieDetailWorker()
    worker?.requestTrailer(path: "\(movie.movieID)")
      .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .background))
      .observeOn(MainScheduler.instance)
      .subscribe(onSuccess: { (result) in
        self.presenter?.presentTrailer(response: result.trailers)
      }, onError: { (error) in
        let errorDict = [Constant.errorKey : error.localizedDescription]
        NotificationCenter.default.post(name: NSNotification.Name(rawValue: "error"), object: nil, userInfo: errorDict as [AnyHashable : Any])
      })
  }
}
